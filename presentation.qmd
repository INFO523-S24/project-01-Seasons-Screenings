---
title: "Exploring Trends in Holiday Movies"
subtitle: "INFO 523 - Spring 2023 - Project 1"
author: "Surya Vardhan Dama<br>
        Rajitha Reddy Tiruthani<br>
        Melika Sharifi<br>
        Maksim Kulik<br>
        Toluwanimi Adegboyega Olorunnisola<br>
        Gowtham Gopalakrishnan"

title-slide-attributes:
  data-background-image: images/watercolour_sys02_img34_teacup-ocean.jpg
  data-background-size: stretch
  data-background-opacity: "0.7"
  data-slide-number: none
format:
  revealjs:
    theme:  ['data/customtheming.scss']
  
editor: visual
jupyter: python3
execute:
  echo: false
---

```{python}
#| label: load-packages
#| include: false

# Load packages here
import pandas as pd
import seaborn as sns
import numpy as np
import matplotlib.pyplot as plt
import missingno as msno

```

```{python}
#| label: setup
#| include: false
#| 
# Set up plot theme and figure resolution
sns.set_theme(style="whitegrid")
sns.set_context("notebook", font_scale=1.1)

import matplotlib.pyplot as plt
plt.rcParams['figure.dpi'] = 300
plt.rcParams['savefig.dpi'] = 300
plt.rcParams['figure.figsize'] = (6, 6 * 0.618)
```

```{python}
#| label: load-data
#| include: false
# Load data in Python
df = pd.read_csv('data/holiday_movies.csv')
new_genres = pd.read_csv('data/holiday_movie_genres.csv')
# display the first five rows of the dataset

```

## Introduction {style="font-size: 0.7em;"}

- Our Project explores a dataset covering holiday-themed films from 1929 to 2022, including details like movie titles, release years, runtime, genres, ratings, and holiday associations.
- The dataset includes crucial information such as movie titles, release years, runtime, genres, ratings, and indicators for major holidays like Christmas, Hanukkah, and Kwanzaa.
- Our analysis looked at how popular holiday movies have changed from the 1920s to the 2020s, showing how audience tastes and movie styles evolved.
- We also examined, which types of holiday movies tend to earn the most money, helping filmmakers and studios understand what audiences are willing to pay for.

## Question 1: {style="font-size: 0.7em;"}

**How have popular movies changed over the decades?**

## Approach {style="font-size: 0.7em;"}

<br>
1.Quartile approach ensures representative observations by identifying popular films based on average ratings.<br><br>
2.To identify changes in the popularity of a genre, a multifaceted bar chart shows the genre distribution in the top quartiles across several decades.<br><br>
3.The scatter plot illustrates trends in preferred movie lengths and title lengths throughout time by correlating movie duration and average rating, color-coded by title length.<br><br>
4.Combining approaches reveals changes in industry trends and consumer tastes over decades in well-known Christmas films.

### Plot {style="font-size: 0.65em;"}

```{python}
# Drop rows where 'genres' is missing 
df_cleaned = df.dropna(subset=['genres']).copy()

# Impute missing values in 'runtime_minutes' with the median of the non-missing values
median_runtime = df_cleaned['runtime_minutes'].median()
df_cleaned.loc[:, 'runtime_minutes'] = df_cleaned['runtime_minutes'].fillna(median_runtime)

# Verify the imputation by checking if there are still missing values in 'runtime_minutes'
missing_after_imputation = df_cleaned.isnull().sum()
#print(f"Missing Value after modification : {missing_after_imputation}")

# Calculate the length of each movie title using .loc to safely modify the DataFrame
df_cleaned.loc[:, 'title_length'] = df_cleaned['original_title'].apply(len)

# Determine the rating quartile for each movie
df_cleaned.loc[:, 'rating_quartile'] = pd.qcut(df_cleaned['average_rating'], 4, labels=False)

# Count the number of genres per movie, handling NaN if present
df_cleaned.loc[:, 'genre_count'] = df_cleaned['genres'].apply(lambda x: len(x.split(',')) if pd.notnull(x) else 0)

# Filter to include only movies in the 3rd and 4th rating quartiles and use .copy() for top_movies
top_movies = df_cleaned[df_cleaned['rating_quartile'] >= 2].copy()

# Organize the data by decades using .loc to avoid SettingWithCopyWarning
top_movies.loc[:, 'decade'] = (top_movies['year'] // 10) * 10

#Merge the new genre dataset with the  existing cleaned DataFrame
merged_df = pd.merge(top_movies, new_genres, on = 'tconst', how = 'left')

# display the first five rows of top_movies
#top_movies.head()

# Count the frequency of each genre within the 3rd and 4th rating quartiles
genre_counts = merged_df['genres_y'].value_counts()
plt.figure(figsize=(12, 8))
sns.barplot(x = genre_counts.values, y = genre_counts.index, hue = genre_counts.index, palette = 'viridis', legend = False)
plt.xlabel('Number of Movies')
plt.ylabel('Genre')
plt.title('Most Common Genres Among Top-Rated Holiday Movies')
plt.show()
```
### Insights

- From the genre distribution bar plot, we can observe that Comedy and Drama are the most common genres among top-rated holiday movies. 
- This predominance might suggest that audiences tend to prefer lighter and more emotionally resonant stories during holiday seasons, which aligns with the festive and familial spirit of such times. 
- Family and Romance genres follow, which further emphasizes the desire for movies that bring people together, reflecting typical holiday themes centered around love, family, and togetherness.

```{python}
# Create a boxplot to visualize the distribution of movie runtimes across different rating quartiles
# 'x' specifies the categorical variable 'rating_quartile' for the x-axis
# 'y' specifies the numerical variable 'runtime_minutes' for the y-axis
plt.figure(figsize=(12, 8))
sns.boxplot(x = "rating_quartile", y = "runtime_minutes", data = top_movies)
plt.xlabel("Rating Quartile")
plt.ylabel("Runtime(min)")
plt.title("Rating Quartile vs Runtime in Movies")
plt.show()
```
### Insights
- The plot showcasing the relationship between movie runtime and rating quartile indicates that there isn’t a strong preference for movie length within the top rating quartiles. 
- While there is a concentration of movies with runtimes around 100 minutes (typical for standard feature films), the presence of highly-rated movies with longer runtimes suggests that a film’s duration is less significant to its reception compared to other factors such as story, acting, and direction. 
- However, the spread of runtimes in the 3rd quartile is narrower than in the 4th, hinting that exceptionally well-received movies might have a tighter consistency in their duration.

```{python}
# Create a line plot to visualize the relationship between the length of movie titles and their average ratings
# 'x' specifies the numerical variable 'title_length' for the x-axis
# 'y' specifies the numerical variable 'average_rating' for the y-axis
plt.figure(figsize=(12, 8))
sns.lineplot(x = "title_length", y = "average_rating", data = top_movies, color = "purple", errorbar = None)
x_intervals = np.arange(0, max(top_movies['title_length']) + 10, 10)
plt.xticks(x_intervals)
plt.xlabel("Title Length")
plt.ylabel("Average Rating")
plt.title("Title Length vs Average Rating in Movies")
plt.show()
```
### Insights
- The line plot correlating title length with average rating shows a more erratic relationship. 
- While no clear trend is discernible, there appears to be a slight tendency for movies with shorter titles to have higher ratings, although there are exceptions at various points. 
- This might imply that conciseness in a title could be associated with a film’s memorability or marketing effectiveness, but the numerous outliers make it difficult to draw a definitive conclusion.

## Question 2:  {style="font-size: 0.7em;"}


## Layouts

You can use plain text

::: columns
::: {.column width="40%"}
-   or bullet points[^1]
:::

::: {.column width="60%"}
or in two columns
:::
:::

[^1]: And add footnotes

-   like

-   this

## Code

```{python}
from sklearn.linear_model import LinearRegression
import statsmodels.api as sm
import pandas as pd

# Fit a linear regression model
X = mtcars[['speed']]
y = mtcars['mpg']
model = LinearRegression().fit(X, y)

# Summary of the model
X2 = sm.add_constant(X)
est = sm.OLS(y, X2)
est2 = est.fit()
print(est2.summary())
```

## Plots

```{python}
penguins['species'] = penguins['species'].apply(lambda x: "Adelie" if x == "Adelie" else "Other")
sns.scatterplot(data=penguins, x='flipper_length_mm', y='body_mass_g', hue='species')
plt.show()
```

## Plot and text

::: columns
::: {.column width="50%"}
-   Some text

-   goes here
:::

::: {.column width="50%"}
```{python}
#| warning: false
#| fig.width: 5.5
fig, ax = plt.subplots(figsize=(5.5, 5.5 * 0.618))
sns.boxplot(data=penguins, x='bill_length_mm', y='species', hue='species', ax=ax)
plt.show()
```
:::
:::

# A new section...

## Tables

If you want to generate a table, make sure it is in the HTML format (instead of Markdown or other formats), e.g.,

```{python}
penguins.head().to_html()
```

## Images

![Image credit: Danielle Navarro, Percolate.](images/watercolour_sys02_img34_teacup-ocean.png){fig-align="center" width="500"}

## Math Expressions {.smaller}

You can write LaTeX math expressions inside a pair of dollar signs, e.g. \$\\alpha+\\beta\$ renders $\alpha + \beta$. You can use the display style with double dollar signs:

```         
$$\bar{X}=\frac{1}{n}\sum_{i=1}^nX_i$$
```

$$
\bar{X}=\frac{1}{n}\sum_{i=1}^nX_i
$$

Limitations:

1.  The source code of a LaTeX math expression must be in one line, unless it is inside a pair of double dollar signs, in which case the starting `$$` must appear in the very beginning of a line, followed immediately by a non-space character, and the ending `$$` must be at the end of a line, led by a non-space character;

2.  There should not be spaces after the opening `$` or before the closing `$`.

# Wrap up

## Feeling adventurous?

-   You are welcomed to use the default styling of the slides. In fact, that's what I expect majority of you will do. You will differentiate yourself with the content of your presentation.

-   But some of you might want to play around with slide styling. Some solutions for this can be found at https://quarto.org/docs/presentations/revealjs.
